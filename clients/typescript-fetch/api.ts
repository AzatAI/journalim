/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * JBS Backend Service
 * Journalim Protocol Compatible Backend Service
 *
 * OpenAPI spec version: 0.0.1
 * Contact: a@azat.ai
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://journalim.gepsoz.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AttachmentCreate
 */
export interface AttachmentCreate {
    /**
     * 
     * @type {string}
     * @memberof AttachmentCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentCreate
     */
    path: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentCreate
     */
    contentType: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentCreate
     */
    accessUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentCreate
     */
    accessType?: string;
    /**
     * 
     * @type {number}
     * @memberof AttachmentCreate
     */
    issueId?: number;
}
/**
 * 
 * @export
 * @interface AttachmentRead
 */
export interface AttachmentRead {
    /**
     * 
     * @type {Date}
     * @memberof AttachmentRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AttachmentRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof AttachmentRead
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentRead
     */
    path: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentRead
     */
    contentType: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentRead
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentRead
     */
    accessUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentRead
     */
    accessType?: string;
    /**
     * 
     * @type {number}
     * @memberof AttachmentRead
     */
    issueId?: number;
    /**
     * 
     * @type {number}
     * @memberof AttachmentRead
     */
    id: number;
}
/**
 * 
 * @export
 * @interface AttachmentUpdate
 */
export interface AttachmentUpdate {
    /**
     * 
     * @type {string}
     * @memberof AttachmentUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentUpdate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface BodyCreateTokenTokenPost
 */
export interface BodyCreateTokenTokenPost {
    /**
     * 
     * @type {string}
     * @memberof BodyCreateTokenTokenPost
     */
    grantType?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateTokenTokenPost
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateTokenTokenPost
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateTokenTokenPost
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateTokenTokenPost
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyCreateTokenTokenPost
     */
    clientSecret?: string;
}
/**
 * 
 * @export
 * @interface BodyCreateUploadUploadPost
 */
export interface BodyCreateUploadUploadPost {
    /**
     * 
     * @type {Blob}
     * @memberof BodyCreateUploadUploadPost
     */
    file: Blob;
}
/**
 * 
 * @export
 * @interface ErrorResponseModel
 */
export interface ErrorResponseModel {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseModel
     */
    message: string;
}
/**
 * 
 * @export
 * @interface GenericFileUploadResponse
 */
export interface GenericFileUploadResponse {
    /**
     * 
     * @type {string}
     * @memberof GenericFileUploadResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GenericFileUploadResponse
     */
    contentType: string;
    /**
     * 
     * @type {string}
     * @memberof GenericFileUploadResponse
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericFileUploadResponse
     */
    accessUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericFileUploadResponse
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericFileUploadResponse
     */
    accessType?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface IssueCreate
 */
export interface IssueCreate {
    /**
     * 
     * @type {string}
     * @memberof IssueCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof IssueCreate
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof IssueCreate
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueCreate
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueCreate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueCreate
     */
    longDescription?: string;
    /**
     * 
     * @type {number}
     * @memberof IssueCreate
     */
    publicationId?: number;
}
/**
 * 
 * @export
 * @interface IssueLanguageCreate
 */
export interface IssueLanguageCreate {
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageCreate
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageCreate
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageCreate
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageCreate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageCreate
     */
    longDescription?: string;
    /**
     * 
     * @type {number}
     * @memberof IssueLanguageCreate
     */
    issueId?: number;
    /**
     * 
     * @type {number}
     * @memberof IssueLanguageCreate
     */
    languageId?: number;
}
/**
 * 
 * @export
 * @interface IssueLanguageRead
 */
export interface IssueLanguageRead {
    /**
     * 
     * @type {Date}
     * @memberof IssueLanguageRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof IssueLanguageRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageRead
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageRead
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageRead
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageRead
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageRead
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageRead
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageRead
     */
    longDescription?: string;
    /**
     * 
     * @type {number}
     * @memberof IssueLanguageRead
     */
    issueId?: number;
    /**
     * 
     * @type {number}
     * @memberof IssueLanguageRead
     */
    languageId?: number;
    /**
     * 
     * @type {number}
     * @memberof IssueLanguageRead
     */
    id: number;
}
/**
 * 
 * @export
 * @interface IssueLanguageUpdate
 */
export interface IssueLanguageUpdate {
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageUpdate
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageUpdate
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageUpdate
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageUpdate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueLanguageUpdate
     */
    longDescription?: string;
}
/**
 * 
 * @export
 * @interface IssueRead
 */
export interface IssueRead {
    /**
     * 
     * @type {Date}
     * @memberof IssueRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof IssueRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof IssueRead
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof IssueRead
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof IssueRead
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueRead
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueRead
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueRead
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueRead
     */
    longDescription?: string;
    /**
     * 
     * @type {number}
     * @memberof IssueRead
     */
    publicationId?: number;
    /**
     * 
     * @type {number}
     * @memberof IssueRead
     */
    id: number;
}
/**
 * 
 * @export
 * @interface IssueUpdate
 */
export interface IssueUpdate {
    /**
     * 
     * @type {string}
     * @memberof IssueUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueUpdate
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueUpdate
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueUpdate
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueUpdate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof IssueUpdate
     */
    longDescription?: string;
}
/**
 * 
 * @export
 * @interface LanguageCreate
 */
export interface LanguageCreate {
    /**
     * 
     * @type {string}
     * @memberof LanguageCreate
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof LanguageCreate
     */
    nameLocal: string;
    /**
     * 
     * @type {string}
     * @memberof LanguageCreate
     */
    nameGlobal?: string;
}
/**
 * 
 * @export
 * @interface LanguageRead
 */
export interface LanguageRead {
    /**
     * 
     * @type {Date}
     * @memberof LanguageRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof LanguageRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof LanguageRead
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof LanguageRead
     */
    nameLocal: string;
    /**
     * 
     * @type {string}
     * @memberof LanguageRead
     */
    nameGlobal?: string;
    /**
     * 
     * @type {number}
     * @memberof LanguageRead
     */
    id: number;
}
/**
 * 
 * @export
 * @interface LanguageUpdate
 */
export interface LanguageUpdate {
    /**
     * 
     * @type {string}
     * @memberof LanguageUpdate
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof LanguageUpdate
     */
    nameLocal?: string;
    /**
     * 
     * @type {string}
     * @memberof LanguageUpdate
     */
    nameGlobal?: string;
}
/**
 * 
 * @export
 * @interface MediaRead
 */
export interface MediaRead {
    /**
     * 
     * @type {Date}
     * @memberof MediaRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof MediaRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    path: string;
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    contentType: string;
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    accessUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    accessType?: string;
    /**
     * 
     * @type {number}
     * @memberof MediaRead
     */
    id: number;
}
/**
 * 
 * @export
 * @interface MediaUpdate
 */
export interface MediaUpdate {
    /**
     * 
     * @type {string}
     * @memberof MediaUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaUpdate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface PageCreate
 */
export interface PageCreate {
    /**
     * 
     * @type {string}
     * @memberof PageCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof PageCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PageCreate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PageCreate
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof PageCreate
     */
    featuredImage?: string;
    /**
     * 
     * @type {string}
     * @memberof PageCreate
     */
    content?: string;
    /**
     * A Page must belongs to one of the site.
     * @type {number}
     * @memberof PageCreate
     */
    siteId?: number;
}
/**
 * 
 * @export
 * @interface PageLanguageCreate
 */
export interface PageLanguageCreate {
    /**
     * 
     * @type {string}
     * @memberof PageLanguageCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof PageLanguageCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PageLanguageCreate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PageLanguageCreate
     */
    content?: string;
    /**
     * 
     * @type {number}
     * @memberof PageLanguageCreate
     */
    pageId?: number;
    /**
     * 
     * @type {number}
     * @memberof PageLanguageCreate
     */
    languageId?: number;
}
/**
 * 
 * @export
 * @interface PageLanguageRead
 */
export interface PageLanguageRead {
    /**
     * 
     * @type {Date}
     * @memberof PageLanguageRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PageLanguageRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof PageLanguageRead
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof PageLanguageRead
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PageLanguageRead
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PageLanguageRead
     */
    content?: string;
    /**
     * 
     * @type {number}
     * @memberof PageLanguageRead
     */
    pageId?: number;
    /**
     * 
     * @type {number}
     * @memberof PageLanguageRead
     */
    languageId?: number;
    /**
     * 
     * @type {number}
     * @memberof PageLanguageRead
     */
    id: number;
}
/**
 * 
 * @export
 * @interface PageLanguageUpdate
 */
export interface PageLanguageUpdate {
    /**
     * 
     * @type {string}
     * @memberof PageLanguageUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PageLanguageUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PageLanguageUpdate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PageLanguageUpdate
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface PageRead
 */
export interface PageRead {
    /**
     * 
     * @type {Date}
     * @memberof PageRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PageRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof PageRead
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof PageRead
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PageRead
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PageRead
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof PageRead
     */
    featuredImage?: string;
    /**
     * 
     * @type {string}
     * @memberof PageRead
     */
    content?: string;
    /**
     * A Page must belongs to one of the site.
     * @type {number}
     * @memberof PageRead
     */
    siteId?: number;
    /**
     * 
     * @type {number}
     * @memberof PageRead
     */
    id: number;
}
/**
 * 
 * @export
 * @interface PageUpdate
 */
export interface PageUpdate {
    /**
     * 
     * @type {string}
     * @memberof PageUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PageUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PageUpdate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PageUpdate
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof PageUpdate
     */
    featuredImage?: string;
    /**
     * 
     * @type {string}
     * @memberof PageUpdate
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface PostCreate
 */
export interface PostCreate {
    /**
     * 
     * @type {string}
     * @memberof PostCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof PostCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PostCreate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PostCreate
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof PostCreate
     */
    featuredImage?: string;
    /**
     * 
     * @type {string}
     * @memberof PostCreate
     */
    content?: string;
    /**
     * A Post must belongs to one of the site.
     * @type {number}
     * @memberof PostCreate
     */
    siteId?: number;
}
/**
 * 
 * @export
 * @interface PostLanguageCreate
 */
export interface PostLanguageCreate {
    /**
     * 
     * @type {string}
     * @memberof PostLanguageCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof PostLanguageCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PostLanguageCreate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PostLanguageCreate
     */
    content?: string;
    /**
     * 
     * @type {number}
     * @memberof PostLanguageCreate
     */
    postId?: number;
    /**
     * 
     * @type {number}
     * @memberof PostLanguageCreate
     */
    languageId?: number;
}
/**
 * 
 * @export
 * @interface PostLanguageRead
 */
export interface PostLanguageRead {
    /**
     * 
     * @type {Date}
     * @memberof PostLanguageRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PostLanguageRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof PostLanguageRead
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof PostLanguageRead
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PostLanguageRead
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PostLanguageRead
     */
    content?: string;
    /**
     * 
     * @type {number}
     * @memberof PostLanguageRead
     */
    postId?: number;
    /**
     * 
     * @type {number}
     * @memberof PostLanguageRead
     */
    languageId?: number;
    /**
     * 
     * @type {number}
     * @memberof PostLanguageRead
     */
    id: number;
}
/**
 * 
 * @export
 * @interface PostLanguageUpdate
 */
export interface PostLanguageUpdate {
    /**
     * 
     * @type {string}
     * @memberof PostLanguageUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PostLanguageUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PostLanguageUpdate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PostLanguageUpdate
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface PostRead
 */
export interface PostRead {
    /**
     * 
     * @type {Date}
     * @memberof PostRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PostRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof PostRead
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof PostRead
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PostRead
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PostRead
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof PostRead
     */
    featuredImage?: string;
    /**
     * 
     * @type {string}
     * @memberof PostRead
     */
    content?: string;
    /**
     * A Post must belongs to one of the site.
     * @type {number}
     * @memberof PostRead
     */
    siteId?: number;
    /**
     * 
     * @type {number}
     * @memberof PostRead
     */
    id: number;
}
/**
 * 
 * @export
 * @interface PostUpdate
 */
export interface PostUpdate {
    /**
     * 
     * @type {string}
     * @memberof PostUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PostUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PostUpdate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PostUpdate
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof PostUpdate
     */
    featuredImage?: string;
    /**
     * 
     * @type {string}
     * @memberof PostUpdate
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface PublicationCreate
 */
export interface PublicationCreate {
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    publisher?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    issn?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    isbn?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    editorInChief?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    editorOthers?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    contactPerson?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    contactEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    contactNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    contactAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    subscriptionFee?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationCreate
     */
    keywords?: string;
    /**
     * This can be a very long html or markdown content
     * @type {string}
     * @memberof PublicationCreate
     */
    longDescription?: string;
}
/**
 * 
 * @export
 * @interface PublicationLanguageCreate
 */
export interface PublicationLanguageCreate {
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageCreate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageCreate
     */
    publisher?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageCreate
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageCreate
     */
    keywords?: string;
    /**
     * This can be a very long html or markdown content
     * @type {string}
     * @memberof PublicationLanguageCreate
     */
    longDescription?: string;
    /**
     * 
     * @type {number}
     * @memberof PublicationLanguageCreate
     */
    publicationId?: number;
    /**
     * 
     * @type {number}
     * @memberof PublicationLanguageCreate
     */
    languageId?: number;
}
/**
 * 
 * @export
 * @interface PublicationLanguageRead
 */
export interface PublicationLanguageRead {
    /**
     * 
     * @type {Date}
     * @memberof PublicationLanguageRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PublicationLanguageRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageRead
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageRead
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageRead
     */
    publisher?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageRead
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageRead
     */
    keywords?: string;
    /**
     * This can be a very long html or markdown content
     * @type {string}
     * @memberof PublicationLanguageRead
     */
    longDescription?: string;
    /**
     * 
     * @type {number}
     * @memberof PublicationLanguageRead
     */
    publicationId?: number;
    /**
     * 
     * @type {number}
     * @memberof PublicationLanguageRead
     */
    languageId?: number;
    /**
     * 
     * @type {number}
     * @memberof PublicationLanguageRead
     */
    id: number;
}
/**
 * 
 * @export
 * @interface PublicationLanguageUpdate
 */
export interface PublicationLanguageUpdate {
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageUpdate
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageUpdate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationLanguageUpdate
     */
    longDescription?: string;
}
/**
 * 
 * @export
 * @interface PublicationRead
 */
export interface PublicationRead {
    /**
     * 
     * @type {Date}
     * @memberof PublicationRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof PublicationRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    publisher?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    issn?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    isbn?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    editorInChief?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    editorOthers?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    contactPerson?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    contactEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    contactNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    contactAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    subscriptionFee?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationRead
     */
    keywords?: string;
    /**
     * This can be a very long html or markdown content
     * @type {string}
     * @memberof PublicationRead
     */
    longDescription?: string;
    /**
     * 
     * @type {number}
     * @memberof PublicationRead
     */
    id: number;
}
/**
 * 
 * @export
 * @interface PublicationUpdate
 */
export interface PublicationUpdate {
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    publisher?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    issn?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    isbn?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    editorInChief?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    editorOthers?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    contactPerson?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    contactEmail?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    contactNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    contactAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    subscriptionFee?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicationUpdate
     */
    longDescription?: string;
}
/**
 * 
 * @export
 * @interface SiteCreate
 */
export interface SiteCreate {
    /**
     * 
     * @type {string}
     * @memberof SiteCreate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof SiteCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteCreate
     */
    logo?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteCreate
     */
    siteUrl?: string;
}
/**
 * 
 * @export
 * @interface SiteLanguageCreate
 */
export interface SiteLanguageCreate {
    /**
     * 
     * @type {string}
     * @memberof SiteLanguageCreate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteLanguageCreate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteLanguageCreate
     */
    alternativeLogo?: string;
    /**
     * 
     * @type {number}
     * @memberof SiteLanguageCreate
     */
    siteId?: number;
    /**
     * 
     * @type {number}
     * @memberof SiteLanguageCreate
     */
    languageId?: number;
}
/**
 * 
 * @export
 * @interface SiteLanguageRead
 */
export interface SiteLanguageRead {
    /**
     * 
     * @type {Date}
     * @memberof SiteLanguageRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SiteLanguageRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof SiteLanguageRead
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteLanguageRead
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteLanguageRead
     */
    alternativeLogo?: string;
    /**
     * 
     * @type {number}
     * @memberof SiteLanguageRead
     */
    siteId?: number;
    /**
     * 
     * @type {number}
     * @memberof SiteLanguageRead
     */
    languageId?: number;
    /**
     * 
     * @type {number}
     * @memberof SiteLanguageRead
     */
    id: number;
}
/**
 * 
 * @export
 * @interface SiteLanguageUpdate
 */
export interface SiteLanguageUpdate {
    /**
     * 
     * @type {string}
     * @memberof SiteLanguageUpdate
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteLanguageUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteLanguageUpdate
     */
    alternativeLogo?: string;
    /**
     * 
     * @type {number}
     * @memberof SiteLanguageUpdate
     */
    siteId?: number;
    /**
     * 
     * @type {number}
     * @memberof SiteLanguageUpdate
     */
    languageId?: number;
}
/**
 * 
 * @export
 * @interface SiteRead
 */
export interface SiteRead {
    /**
     * 
     * @type {Date}
     * @memberof SiteRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SiteRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof SiteRead
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof SiteRead
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteRead
     */
    logo?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteRead
     */
    siteUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof SiteRead
     */
    id: number;
}
/**
 * 
 * @export
 * @interface SiteUpdate
 */
export interface SiteUpdate {
    /**
     * 
     * @type {string}
     * @memberof SiteUpdate
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdate
     */
    logo?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdate
     */
    siteUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdate
     */
    defaultTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteUpdate
     */
    defaultDescription?: string;
}
/**
 * 
 * @export
 * @interface SuccessResponseModel
 */
export interface SuccessResponseModel {
    /**
     * 
     * @type {string}
     * @memberof SuccessResponseModel
     */
    message: string;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    tokenType: string;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    fullname?: string;
    /**
     * 
     * @type {Date}
     * @memberof UserCreate
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UserCreate
     */
    updatedAt?: Date;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    password: string;
}
/**
 * 
 * @export
 * @interface UserRead
 */
export interface UserRead {
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    fullname?: string;
    /**
     * 
     * @type {Date}
     * @memberof UserRead
     */
    createdAt?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UserRead
     */
    updatedAt?: Date;
    /**
     * 
     * @type {number}
     * @memberof UserRead
     */
    id: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserRead
     */
    isStaff?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRead
     */
    isAdmin?: boolean;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    fullname?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    email?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    isStaff?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    isAdmin?: boolean;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string | number>}
     * @memberof ValidationError
     */
    loc: Array<string | number>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}
/**
 * AttachmentApi - fetch parameter creator
 * @export
 */
export const AttachmentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Attachment.
         * @summary Create Attachment
         * @param {AttachmentCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachmentAttachmentsPost(body: AttachmentCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAttachmentAttachmentsPost.');
            }
            const localVarPath = `/attachments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AttachmentCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Attachment
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachmentAttachmentsAttachmentIdDelete(attachmentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling deleteAttachmentAttachmentsAttachmentIdDelete.');
            }
            const localVarPath = `/attachments/{attachment_id}`
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Attachment
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAttachmentAttachmentsAttachmentIdGet(attachmentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling readAttachmentAttachmentsAttachmentIdGet.');
            }
            const localVarPath = `/attachments/{attachment_id}`
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Attachment.
         * @summary Read Attachments
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAttachmentsAttachmentsGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/attachments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Attachment
         * @param {AttachmentUpdate} body 
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachmentAttachmentsAttachmentIdPatch(body: AttachmentUpdate, attachmentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAttachmentAttachmentsAttachmentIdPatch.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling updateAttachmentAttachmentsAttachmentIdPatch.');
            }
            const localVarPath = `/attachments/{attachment_id}`
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AttachmentUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttachmentApi - functional programming interface
 * @export
 */
export const AttachmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a Attachment.
         * @summary Create Attachment
         * @param {AttachmentCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachmentAttachmentsPost(body: AttachmentCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AttachmentRead> {
            const localVarFetchArgs = AttachmentApiFetchParamCreator(configuration).createAttachmentAttachmentsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Attachment
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachmentAttachmentsAttachmentIdDelete(attachmentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = AttachmentApiFetchParamCreator(configuration).deleteAttachmentAttachmentsAttachmentIdDelete(attachmentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Attachment
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAttachmentAttachmentsAttachmentIdGet(attachmentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AttachmentRead> {
            const localVarFetchArgs = AttachmentApiFetchParamCreator(configuration).readAttachmentAttachmentsAttachmentIdGet(attachmentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Attachment.
         * @summary Read Attachments
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAttachmentsAttachmentsGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AttachmentRead>> {
            const localVarFetchArgs = AttachmentApiFetchParamCreator(configuration).readAttachmentsAttachmentsGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Attachment
         * @param {AttachmentUpdate} body 
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachmentAttachmentsAttachmentIdPatch(body: AttachmentUpdate, attachmentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AttachmentRead> {
            const localVarFetchArgs = AttachmentApiFetchParamCreator(configuration).updateAttachmentAttachmentsAttachmentIdPatch(body, attachmentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AttachmentApi - factory interface
 * @export
 */
export const AttachmentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a Attachment.
         * @summary Create Attachment
         * @param {AttachmentCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachmentAttachmentsPost(body: AttachmentCreate, options?: any) {
            return AttachmentApiFp(configuration).createAttachmentAttachmentsPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Attachment
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachmentAttachmentsAttachmentIdDelete(attachmentId: number, options?: any) {
            return AttachmentApiFp(configuration).deleteAttachmentAttachmentsAttachmentIdDelete(attachmentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Attachment
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAttachmentAttachmentsAttachmentIdGet(attachmentId: number, options?: any) {
            return AttachmentApiFp(configuration).readAttachmentAttachmentsAttachmentIdGet(attachmentId, options)(fetch, basePath);
        },
        /**
         * Get all Attachment.
         * @summary Read Attachments
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAttachmentsAttachmentsGet(q?: string, offset?: number, limit?: number, options?: any) {
            return AttachmentApiFp(configuration).readAttachmentsAttachmentsGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Attachment
         * @param {AttachmentUpdate} body 
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachmentAttachmentsAttachmentIdPatch(body: AttachmentUpdate, attachmentId: number, options?: any) {
            return AttachmentApiFp(configuration).updateAttachmentAttachmentsAttachmentIdPatch(body, attachmentId, options)(fetch, basePath);
        },
    };
};

/**
 * AttachmentApi - object-oriented interface
 * @export
 * @class AttachmentApi
 * @extends {BaseAPI}
 */
export class AttachmentApi extends BaseAPI {
    /**
     * Create a Attachment.
     * @summary Create Attachment
     * @param {AttachmentCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentApi
     */
    public createAttachmentAttachmentsPost(body: AttachmentCreate, options?: any) {
        return AttachmentApiFp(this.configuration).createAttachmentAttachmentsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Attachment
     * @param {number} attachmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentApi
     */
    public deleteAttachmentAttachmentsAttachmentIdDelete(attachmentId: number, options?: any) {
        return AttachmentApiFp(this.configuration).deleteAttachmentAttachmentsAttachmentIdDelete(attachmentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Attachment
     * @param {number} attachmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentApi
     */
    public readAttachmentAttachmentsAttachmentIdGet(attachmentId: number, options?: any) {
        return AttachmentApiFp(this.configuration).readAttachmentAttachmentsAttachmentIdGet(attachmentId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all Attachment.
     * @summary Read Attachments
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentApi
     */
    public readAttachmentsAttachmentsGet(q?: string, offset?: number, limit?: number, options?: any) {
        return AttachmentApiFp(this.configuration).readAttachmentsAttachmentsGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Attachment
     * @param {AttachmentUpdate} body 
     * @param {number} attachmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentApi
     */
    public updateAttachmentAttachmentsAttachmentIdPatch(body: AttachmentUpdate, attachmentId: number, options?: any) {
        return AttachmentApiFp(this.configuration).updateAttachmentAttachmentsAttachmentIdPatch(body, attachmentId, options)(this.fetch, this.basePath);
    }

}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingPingGet(options: any = {}): FetchArgs {
            const localVarPath = `/ping`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingPingGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).pingPingGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingPingGet(options?: any) {
            return DefaultApiFp(configuration).pingPingGet(options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pingPingGet(options?: any) {
        return DefaultApiFp(this.configuration).pingPingGet(options)(this.fetch, this.basePath);
    }

}
/**
 * IssueApi - fetch parameter creator
 * @export
 */
export const IssueApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an Issue.
         * @summary Create Issue
         * @param {IssueCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssueIssuesPost(body: IssueCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createIssueIssuesPost.');
            }
            const localVarPath = `/issues`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IssueCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a IssueLanguage.
         * @summary Create Issue Language
         * @param {IssueLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssueLanguageIssueLanguagesPost(body: IssueLanguageCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createIssueLanguageIssueLanguagesPost.');
            }
            const localVarPath = `/issue_languages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IssueLanguageCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Issue
         * @param {number} issueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIssueIssuesIssueIdDelete(issueId: number, options: any = {}): FetchArgs {
            // verify required parameter 'issueId' is not null or undefined
            if (issueId === null || issueId === undefined) {
                throw new RequiredError('issueId','Required parameter issueId was null or undefined when calling deleteIssueIssuesIssueIdDelete.');
            }
            const localVarPath = `/issues/{issue_id}`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Issue Language
         * @param {number} issueLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIssueLanguageIssueLanguagesIssueLanguageIdDelete(issueLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'issueLanguageId' is not null or undefined
            if (issueLanguageId === null || issueLanguageId === undefined) {
                throw new RequiredError('issueLanguageId','Required parameter issueLanguageId was null or undefined when calling deleteIssueLanguageIssueLanguagesIssueLanguageIdDelete.');
            }
            const localVarPath = `/issue_languages/{issue_language_id}`
                .replace(`{${"issue_language_id"}}`, encodeURIComponent(String(issueLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Issue
         * @param {number} issueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIssueIssuesIssueIdGet(issueId: number, options: any = {}): FetchArgs {
            // verify required parameter 'issueId' is not null or undefined
            if (issueId === null || issueId === undefined) {
                throw new RequiredError('issueId','Required parameter issueId was null or undefined when calling readIssueIssuesIssueIdGet.');
            }
            const localVarPath = `/issues/{issue_id}`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Issue Language
         * @param {number} issueLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIssueLanguageIssueLanguagesIssueLanguageIdGet(issueLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'issueLanguageId' is not null or undefined
            if (issueLanguageId === null || issueLanguageId === undefined) {
                throw new RequiredError('issueLanguageId','Required parameter issueLanguageId was null or undefined when calling readIssueLanguageIssueLanguagesIssueLanguageIdGet.');
            }
            const localVarPath = `/issue_languages/{issue_language_id}`
                .replace(`{${"issue_language_id"}}`, encodeURIComponent(String(issueLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all IssueLanguage.
         * @summary Read Issue Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIssueLanguagesIssueLanguagesGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/issue_languages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Issue.
         * @summary Read Issues
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIssuesIssuesGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/issues`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Issue
         * @param {IssueUpdate} body 
         * @param {number} issueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIssueIssuesIssueIdPatch(body: IssueUpdate, issueId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateIssueIssuesIssueIdPatch.');
            }
            // verify required parameter 'issueId' is not null or undefined
            if (issueId === null || issueId === undefined) {
                throw new RequiredError('issueId','Required parameter issueId was null or undefined when calling updateIssueIssuesIssueIdPatch.');
            }
            const localVarPath = `/issues/{issue_id}`
                .replace(`{${"issue_id"}}`, encodeURIComponent(String(issueId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IssueUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Issue Language
         * @param {IssueLanguageUpdate} body 
         * @param {number} issueLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIssueLanguageIssueLanguagesIssueLanguageIdPatch(body: IssueLanguageUpdate, issueLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateIssueLanguageIssueLanguagesIssueLanguageIdPatch.');
            }
            // verify required parameter 'issueLanguageId' is not null or undefined
            if (issueLanguageId === null || issueLanguageId === undefined) {
                throw new RequiredError('issueLanguageId','Required parameter issueLanguageId was null or undefined when calling updateIssueLanguageIssueLanguagesIssueLanguageIdPatch.');
            }
            const localVarPath = `/issue_languages/{issue_language_id}`
                .replace(`{${"issue_language_id"}}`, encodeURIComponent(String(issueLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IssueLanguageUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IssueApi - functional programming interface
 * @export
 */
export const IssueApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create an Issue.
         * @summary Create Issue
         * @param {IssueCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssueIssuesPost(body: IssueCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IssueRead> {
            const localVarFetchArgs = IssueApiFetchParamCreator(configuration).createIssueIssuesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a IssueLanguage.
         * @summary Create Issue Language
         * @param {IssueLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssueLanguageIssueLanguagesPost(body: IssueLanguageCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IssueLanguageRead> {
            const localVarFetchArgs = IssueApiFetchParamCreator(configuration).createIssueLanguageIssueLanguagesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Issue
         * @param {number} issueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIssueIssuesIssueIdDelete(issueId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = IssueApiFetchParamCreator(configuration).deleteIssueIssuesIssueIdDelete(issueId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Issue Language
         * @param {number} issueLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIssueLanguageIssueLanguagesIssueLanguageIdDelete(issueLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = IssueApiFetchParamCreator(configuration).deleteIssueLanguageIssueLanguagesIssueLanguageIdDelete(issueLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Issue
         * @param {number} issueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIssueIssuesIssueIdGet(issueId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IssueRead> {
            const localVarFetchArgs = IssueApiFetchParamCreator(configuration).readIssueIssuesIssueIdGet(issueId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Issue Language
         * @param {number} issueLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIssueLanguageIssueLanguagesIssueLanguageIdGet(issueLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IssueLanguageRead> {
            const localVarFetchArgs = IssueApiFetchParamCreator(configuration).readIssueLanguageIssueLanguagesIssueLanguageIdGet(issueLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all IssueLanguage.
         * @summary Read Issue Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIssueLanguagesIssueLanguagesGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IssueLanguageRead>> {
            const localVarFetchArgs = IssueApiFetchParamCreator(configuration).readIssueLanguagesIssueLanguagesGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Issue.
         * @summary Read Issues
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIssuesIssuesGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IssueRead>> {
            const localVarFetchArgs = IssueApiFetchParamCreator(configuration).readIssuesIssuesGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Issue
         * @param {IssueUpdate} body 
         * @param {number} issueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIssueIssuesIssueIdPatch(body: IssueUpdate, issueId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IssueRead> {
            const localVarFetchArgs = IssueApiFetchParamCreator(configuration).updateIssueIssuesIssueIdPatch(body, issueId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Issue Language
         * @param {IssueLanguageUpdate} body 
         * @param {number} issueLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIssueLanguageIssueLanguagesIssueLanguageIdPatch(body: IssueLanguageUpdate, issueLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IssueLanguageRead> {
            const localVarFetchArgs = IssueApiFetchParamCreator(configuration).updateIssueLanguageIssueLanguagesIssueLanguageIdPatch(body, issueLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IssueApi - factory interface
 * @export
 */
export const IssueApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create an Issue.
         * @summary Create Issue
         * @param {IssueCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssueIssuesPost(body: IssueCreate, options?: any) {
            return IssueApiFp(configuration).createIssueIssuesPost(body, options)(fetch, basePath);
        },
        /**
         * Create a IssueLanguage.
         * @summary Create Issue Language
         * @param {IssueLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssueLanguageIssueLanguagesPost(body: IssueLanguageCreate, options?: any) {
            return IssueApiFp(configuration).createIssueLanguageIssueLanguagesPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Issue
         * @param {number} issueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIssueIssuesIssueIdDelete(issueId: number, options?: any) {
            return IssueApiFp(configuration).deleteIssueIssuesIssueIdDelete(issueId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Issue Language
         * @param {number} issueLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIssueLanguageIssueLanguagesIssueLanguageIdDelete(issueLanguageId: number, options?: any) {
            return IssueApiFp(configuration).deleteIssueLanguageIssueLanguagesIssueLanguageIdDelete(issueLanguageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Issue
         * @param {number} issueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIssueIssuesIssueIdGet(issueId: number, options?: any) {
            return IssueApiFp(configuration).readIssueIssuesIssueIdGet(issueId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Issue Language
         * @param {number} issueLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIssueLanguageIssueLanguagesIssueLanguageIdGet(issueLanguageId: number, options?: any) {
            return IssueApiFp(configuration).readIssueLanguageIssueLanguagesIssueLanguageIdGet(issueLanguageId, options)(fetch, basePath);
        },
        /**
         * Get all IssueLanguage.
         * @summary Read Issue Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIssueLanguagesIssueLanguagesGet(q?: string, offset?: number, limit?: number, options?: any) {
            return IssueApiFp(configuration).readIssueLanguagesIssueLanguagesGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * Get all Issue.
         * @summary Read Issues
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readIssuesIssuesGet(q?: string, offset?: number, limit?: number, options?: any) {
            return IssueApiFp(configuration).readIssuesIssuesGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Issue
         * @param {IssueUpdate} body 
         * @param {number} issueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIssueIssuesIssueIdPatch(body: IssueUpdate, issueId: number, options?: any) {
            return IssueApiFp(configuration).updateIssueIssuesIssueIdPatch(body, issueId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Issue Language
         * @param {IssueLanguageUpdate} body 
         * @param {number} issueLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIssueLanguageIssueLanguagesIssueLanguageIdPatch(body: IssueLanguageUpdate, issueLanguageId: number, options?: any) {
            return IssueApiFp(configuration).updateIssueLanguageIssueLanguagesIssueLanguageIdPatch(body, issueLanguageId, options)(fetch, basePath);
        },
    };
};

/**
 * IssueApi - object-oriented interface
 * @export
 * @class IssueApi
 * @extends {BaseAPI}
 */
export class IssueApi extends BaseAPI {
    /**
     * Create an Issue.
     * @summary Create Issue
     * @param {IssueCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public createIssueIssuesPost(body: IssueCreate, options?: any) {
        return IssueApiFp(this.configuration).createIssueIssuesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a IssueLanguage.
     * @summary Create Issue Language
     * @param {IssueLanguageCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public createIssueLanguageIssueLanguagesPost(body: IssueLanguageCreate, options?: any) {
        return IssueApiFp(this.configuration).createIssueLanguageIssueLanguagesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Issue
     * @param {number} issueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public deleteIssueIssuesIssueIdDelete(issueId: number, options?: any) {
        return IssueApiFp(this.configuration).deleteIssueIssuesIssueIdDelete(issueId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Issue Language
     * @param {number} issueLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public deleteIssueLanguageIssueLanguagesIssueLanguageIdDelete(issueLanguageId: number, options?: any) {
        return IssueApiFp(this.configuration).deleteIssueLanguageIssueLanguagesIssueLanguageIdDelete(issueLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Issue
     * @param {number} issueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public readIssueIssuesIssueIdGet(issueId: number, options?: any) {
        return IssueApiFp(this.configuration).readIssueIssuesIssueIdGet(issueId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Issue Language
     * @param {number} issueLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public readIssueLanguageIssueLanguagesIssueLanguageIdGet(issueLanguageId: number, options?: any) {
        return IssueApiFp(this.configuration).readIssueLanguageIssueLanguagesIssueLanguageIdGet(issueLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all IssueLanguage.
     * @summary Read Issue Languages
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public readIssueLanguagesIssueLanguagesGet(q?: string, offset?: number, limit?: number, options?: any) {
        return IssueApiFp(this.configuration).readIssueLanguagesIssueLanguagesGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Get all Issue.
     * @summary Read Issues
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public readIssuesIssuesGet(q?: string, offset?: number, limit?: number, options?: any) {
        return IssueApiFp(this.configuration).readIssuesIssuesGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Issue
     * @param {IssueUpdate} body 
     * @param {number} issueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public updateIssueIssuesIssueIdPatch(body: IssueUpdate, issueId: number, options?: any) {
        return IssueApiFp(this.configuration).updateIssueIssuesIssueIdPatch(body, issueId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Issue Language
     * @param {IssueLanguageUpdate} body 
     * @param {number} issueLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public updateIssueLanguageIssueLanguagesIssueLanguageIdPatch(body: IssueLanguageUpdate, issueLanguageId: number, options?: any) {
        return IssueApiFp(this.configuration).updateIssueLanguageIssueLanguagesIssueLanguageIdPatch(body, issueLanguageId, options)(this.fetch, this.basePath);
    }

}
/**
 * LanguageApi - fetch parameter creator
 * @export
 */
export const LanguageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Language.
         * @summary Create Language
         * @param {LanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLanguageLanguagesPost(body: LanguageCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createLanguageLanguagesPost.');
            }
            const localVarPath = `/languages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LanguageCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Language
         * @param {number} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLanguageLanguagesLanguageIdDelete(languageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'languageId' is not null or undefined
            if (languageId === null || languageId === undefined) {
                throw new RequiredError('languageId','Required parameter languageId was null or undefined when calling deleteLanguageLanguagesLanguageIdDelete.');
            }
            const localVarPath = `/languages/{language_id}`
                .replace(`{${"language_id"}}`, encodeURIComponent(String(languageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Language
         * @param {number} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readLanguageLanguagesLanguageIdGet(languageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'languageId' is not null or undefined
            if (languageId === null || languageId === undefined) {
                throw new RequiredError('languageId','Required parameter languageId was null or undefined when calling readLanguageLanguagesLanguageIdGet.');
            }
            const localVarPath = `/languages/{language_id}`
                .replace(`{${"language_id"}}`, encodeURIComponent(String(languageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Language.
         * @summary Read Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readLanguagesLanguagesGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/languages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Language
         * @param {LanguageUpdate} body 
         * @param {number} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLanguageLanguagesLanguageIdPatch(body: LanguageUpdate, languageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateLanguageLanguagesLanguageIdPatch.');
            }
            // verify required parameter 'languageId' is not null or undefined
            if (languageId === null || languageId === undefined) {
                throw new RequiredError('languageId','Required parameter languageId was null or undefined when calling updateLanguageLanguagesLanguageIdPatch.');
            }
            const localVarPath = `/languages/{language_id}`
                .replace(`{${"language_id"}}`, encodeURIComponent(String(languageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LanguageUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguageApi - functional programming interface
 * @export
 */
export const LanguageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a Language.
         * @summary Create Language
         * @param {LanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLanguageLanguagesPost(body: LanguageCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LanguageRead> {
            const localVarFetchArgs = LanguageApiFetchParamCreator(configuration).createLanguageLanguagesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Language
         * @param {number} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLanguageLanguagesLanguageIdDelete(languageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = LanguageApiFetchParamCreator(configuration).deleteLanguageLanguagesLanguageIdDelete(languageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Language
         * @param {number} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readLanguageLanguagesLanguageIdGet(languageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LanguageRead> {
            const localVarFetchArgs = LanguageApiFetchParamCreator(configuration).readLanguageLanguagesLanguageIdGet(languageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Language.
         * @summary Read Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readLanguagesLanguagesGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LanguageRead>> {
            const localVarFetchArgs = LanguageApiFetchParamCreator(configuration).readLanguagesLanguagesGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Language
         * @param {LanguageUpdate} body 
         * @param {number} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLanguageLanguagesLanguageIdPatch(body: LanguageUpdate, languageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LanguageRead> {
            const localVarFetchArgs = LanguageApiFetchParamCreator(configuration).updateLanguageLanguagesLanguageIdPatch(body, languageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LanguageApi - factory interface
 * @export
 */
export const LanguageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a Language.
         * @summary Create Language
         * @param {LanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLanguageLanguagesPost(body: LanguageCreate, options?: any) {
            return LanguageApiFp(configuration).createLanguageLanguagesPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Language
         * @param {number} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLanguageLanguagesLanguageIdDelete(languageId: number, options?: any) {
            return LanguageApiFp(configuration).deleteLanguageLanguagesLanguageIdDelete(languageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Language
         * @param {number} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readLanguageLanguagesLanguageIdGet(languageId: number, options?: any) {
            return LanguageApiFp(configuration).readLanguageLanguagesLanguageIdGet(languageId, options)(fetch, basePath);
        },
        /**
         * Get all Language.
         * @summary Read Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readLanguagesLanguagesGet(q?: string, offset?: number, limit?: number, options?: any) {
            return LanguageApiFp(configuration).readLanguagesLanguagesGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Language
         * @param {LanguageUpdate} body 
         * @param {number} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLanguageLanguagesLanguageIdPatch(body: LanguageUpdate, languageId: number, options?: any) {
            return LanguageApiFp(configuration).updateLanguageLanguagesLanguageIdPatch(body, languageId, options)(fetch, basePath);
        },
    };
};

/**
 * LanguageApi - object-oriented interface
 * @export
 * @class LanguageApi
 * @extends {BaseAPI}
 */
export class LanguageApi extends BaseAPI {
    /**
     * Create a Language.
     * @summary Create Language
     * @param {LanguageCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public createLanguageLanguagesPost(body: LanguageCreate, options?: any) {
        return LanguageApiFp(this.configuration).createLanguageLanguagesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Language
     * @param {number} languageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public deleteLanguageLanguagesLanguageIdDelete(languageId: number, options?: any) {
        return LanguageApiFp(this.configuration).deleteLanguageLanguagesLanguageIdDelete(languageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Language
     * @param {number} languageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public readLanguageLanguagesLanguageIdGet(languageId: number, options?: any) {
        return LanguageApiFp(this.configuration).readLanguageLanguagesLanguageIdGet(languageId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all Language.
     * @summary Read Languages
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public readLanguagesLanguagesGet(q?: string, offset?: number, limit?: number, options?: any) {
        return LanguageApiFp(this.configuration).readLanguagesLanguagesGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Language
     * @param {LanguageUpdate} body 
     * @param {number} languageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageApi
     */
    public updateLanguageLanguagesLanguageIdPatch(body: LanguageUpdate, languageId: number, options?: any) {
        return LanguageApiFp(this.configuration).updateLanguageLanguagesLanguageIdPatch(body, languageId, options)(this.fetch, this.basePath);
    }

}
/**
 * MediaApi - fetch parameter creator
 * @export
 */
export const MediaApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload a file to the server.   This file later can be served to user either publicly or privately(for signed-in users only)   Hints: Private files can be used for creating new issue attachments (PDFs)!   <span style:\"color:red\">WARN</span> : Uploading files with same filename might overwrite the existing files.
         * @summary Create Upload
         * @param {Blob} file 
         * @param {boolean} [_public] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadUploadPost(file: Blob, _public?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createUploadUploadPost.');
            }
            const localVarPath = `/upload`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (_public !== undefined) {
                localVarQueryParameter['public'] = _public;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Media
         * @param {number} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaMediasMediaIdDelete(mediaId: number, options: any = {}): FetchArgs {
            // verify required parameter 'mediaId' is not null or undefined
            if (mediaId === null || mediaId === undefined) {
                throw new RequiredError('mediaId','Required parameter mediaId was null or undefined when calling deleteMediaMediasMediaIdDelete.');
            }
            const localVarPath = `/medias/{media_id}`
                .replace(`{${"media_id"}}`, encodeURIComponent(String(mediaId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Media
         * @param {number} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMediaMediasMediaIdGet(mediaId: number, options: any = {}): FetchArgs {
            // verify required parameter 'mediaId' is not null or undefined
            if (mediaId === null || mediaId === undefined) {
                throw new RequiredError('mediaId','Required parameter mediaId was null or undefined when calling readMediaMediasMediaIdGet.');
            }
            const localVarPath = `/medias/{media_id}`
                .replace(`{${"media_id"}}`, encodeURIComponent(String(mediaId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Media.
         * @summary Read Medias
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMediasMediasGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/medias`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Media
         * @param {MediaUpdate} body 
         * @param {number} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaMediasMediaIdPatch(body: MediaUpdate, mediaId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateMediaMediasMediaIdPatch.');
            }
            // verify required parameter 'mediaId' is not null or undefined
            if (mediaId === null || mediaId === undefined) {
                throw new RequiredError('mediaId','Required parameter mediaId was null or undefined when calling updateMediaMediasMediaIdPatch.');
            }
            const localVarPath = `/medias/{media_id}`
                .replace(`{${"media_id"}}`, encodeURIComponent(String(mediaId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MediaUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Upload a file to the server.   This file later can be served to user either publicly or privately(for signed-in users only)   Hints: Private files can be used for creating new issue attachments (PDFs)!   <span style:\"color:red\">WARN</span> : Uploading files with same filename might overwrite the existing files.
         * @summary Create Upload
         * @param {Blob} file 
         * @param {boolean} [_public] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadUploadPost(file: Blob, _public?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GenericFileUploadResponse> {
            const localVarFetchArgs = MediaApiFetchParamCreator(configuration).createUploadUploadPost(file, _public, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Media
         * @param {number} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaMediasMediaIdDelete(mediaId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = MediaApiFetchParamCreator(configuration).deleteMediaMediasMediaIdDelete(mediaId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Media
         * @param {number} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMediaMediasMediaIdGet(mediaId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaRead> {
            const localVarFetchArgs = MediaApiFetchParamCreator(configuration).readMediaMediasMediaIdGet(mediaId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Media.
         * @summary Read Medias
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMediasMediasGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MediaRead>> {
            const localVarFetchArgs = MediaApiFetchParamCreator(configuration).readMediasMediasGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Media
         * @param {MediaUpdate} body 
         * @param {number} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaMediasMediaIdPatch(body: MediaUpdate, mediaId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaRead> {
            const localVarFetchArgs = MediaApiFetchParamCreator(configuration).updateMediaMediasMediaIdPatch(body, mediaId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Upload a file to the server.   This file later can be served to user either publicly or privately(for signed-in users only)   Hints: Private files can be used for creating new issue attachments (PDFs)!   <span style:\"color:red\">WARN</span> : Uploading files with same filename might overwrite the existing files.
         * @summary Create Upload
         * @param {Blob} file 
         * @param {boolean} [_public] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUploadUploadPost(file: Blob, _public?: boolean, options?: any) {
            return MediaApiFp(configuration).createUploadUploadPost(file, _public, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Media
         * @param {number} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaMediasMediaIdDelete(mediaId: number, options?: any) {
            return MediaApiFp(configuration).deleteMediaMediasMediaIdDelete(mediaId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Media
         * @param {number} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMediaMediasMediaIdGet(mediaId: number, options?: any) {
            return MediaApiFp(configuration).readMediaMediasMediaIdGet(mediaId, options)(fetch, basePath);
        },
        /**
         * Get all Media.
         * @summary Read Medias
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMediasMediasGet(q?: string, offset?: number, limit?: number, options?: any) {
            return MediaApiFp(configuration).readMediasMediasGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Media
         * @param {MediaUpdate} body 
         * @param {number} mediaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaMediasMediaIdPatch(body: MediaUpdate, mediaId: number, options?: any) {
            return MediaApiFp(configuration).updateMediaMediasMediaIdPatch(body, mediaId, options)(fetch, basePath);
        },
    };
};

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
    /**
     * Upload a file to the server.   This file later can be served to user either publicly or privately(for signed-in users only)   Hints: Private files can be used for creating new issue attachments (PDFs)!   <span style:\"color:red\">WARN</span> : Uploading files with same filename might overwrite the existing files.
     * @summary Create Upload
     * @param {Blob} file 
     * @param {boolean} [_public] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public createUploadUploadPost(file: Blob, _public?: boolean, options?: any) {
        return MediaApiFp(this.configuration).createUploadUploadPost(file, _public, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Media
     * @param {number} mediaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public deleteMediaMediasMediaIdDelete(mediaId: number, options?: any) {
        return MediaApiFp(this.configuration).deleteMediaMediasMediaIdDelete(mediaId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Media
     * @param {number} mediaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public readMediaMediasMediaIdGet(mediaId: number, options?: any) {
        return MediaApiFp(this.configuration).readMediaMediasMediaIdGet(mediaId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all Media.
     * @summary Read Medias
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public readMediasMediasGet(q?: string, offset?: number, limit?: number, options?: any) {
        return MediaApiFp(this.configuration).readMediasMediasGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Media
     * @param {MediaUpdate} body 
     * @param {number} mediaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public updateMediaMediasMediaIdPatch(body: MediaUpdate, mediaId: number, options?: any) {
        return MediaApiFp(this.configuration).updateMediaMediasMediaIdPatch(body, mediaId, options)(this.fetch, this.basePath);
    }

}
/**
 * PageApi - fetch parameter creator
 * @export
 */
export const PageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a PageLanguage.
         * @summary Create Page Language
         * @param {PageLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPageLanguagePageLanguagesPost(body: PageLanguageCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPageLanguagePageLanguagesPost.');
            }
            const localVarPath = `/page_languages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PageLanguageCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Page.
         * @summary Create Page
         * @param {PageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPagePagesPost(body: PageCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPagePagesPost.');
            }
            const localVarPath = `/pages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PageCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Page Language
         * @param {number} pageLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePageLanguagePageLanguagesPageLanguageIdDelete(pageLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'pageLanguageId' is not null or undefined
            if (pageLanguageId === null || pageLanguageId === undefined) {
                throw new RequiredError('pageLanguageId','Required parameter pageLanguageId was null or undefined when calling deletePageLanguagePageLanguagesPageLanguageIdDelete.');
            }
            const localVarPath = `/page_languages/{page_language_id}`
                .replace(`{${"page_language_id"}}`, encodeURIComponent(String(pageLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Page
         * @param {number} pageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePagePagesPageIdDelete(pageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'pageId' is not null or undefined
            if (pageId === null || pageId === undefined) {
                throw new RequiredError('pageId','Required parameter pageId was null or undefined when calling deletePagePagesPageIdDelete.');
            }
            const localVarPath = `/pages/{page_id}`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Page Language
         * @param {number} pageLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPageLanguagePageLanguagesPageLanguageIdGet(pageLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'pageLanguageId' is not null or undefined
            if (pageLanguageId === null || pageLanguageId === undefined) {
                throw new RequiredError('pageLanguageId','Required parameter pageLanguageId was null or undefined when calling readPageLanguagePageLanguagesPageLanguageIdGet.');
            }
            const localVarPath = `/page_languages/{page_language_id}`
                .replace(`{${"page_language_id"}}`, encodeURIComponent(String(pageLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all PageLanguage.
         * @summary Read Page Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPageLanguagesPageLanguagesGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/page_languages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Page
         * @param {number} pageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPagePagesPageIdGet(pageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'pageId' is not null or undefined
            if (pageId === null || pageId === undefined) {
                throw new RequiredError('pageId','Required parameter pageId was null or undefined when calling readPagePagesPageIdGet.');
            }
            const localVarPath = `/pages/{page_id}`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Page.
         * @summary Read Pages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPagesPagesGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/pages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Page Language
         * @param {PageLanguageUpdate} body 
         * @param {number} pageLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageLanguagePageLanguagesPageLanguageIdPatch(body: PageLanguageUpdate, pageLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePageLanguagePageLanguagesPageLanguageIdPatch.');
            }
            // verify required parameter 'pageLanguageId' is not null or undefined
            if (pageLanguageId === null || pageLanguageId === undefined) {
                throw new RequiredError('pageLanguageId','Required parameter pageLanguageId was null or undefined when calling updatePageLanguagePageLanguagesPageLanguageIdPatch.');
            }
            const localVarPath = `/page_languages/{page_language_id}`
                .replace(`{${"page_language_id"}}`, encodeURIComponent(String(pageLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PageLanguageUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Page
         * @param {PageUpdate} body 
         * @param {number} pageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePagePagesPageIdPatch(body: PageUpdate, pageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePagePagesPageIdPatch.');
            }
            // verify required parameter 'pageId' is not null or undefined
            if (pageId === null || pageId === undefined) {
                throw new RequiredError('pageId','Required parameter pageId was null or undefined when calling updatePagePagesPageIdPatch.');
            }
            const localVarPath = `/pages/{page_id}`
                .replace(`{${"page_id"}}`, encodeURIComponent(String(pageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PageUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PageApi - functional programming interface
 * @export
 */
export const PageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a PageLanguage.
         * @summary Create Page Language
         * @param {PageLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPageLanguagePageLanguagesPost(body: PageLanguageCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageLanguageRead> {
            const localVarFetchArgs = PageApiFetchParamCreator(configuration).createPageLanguagePageLanguagesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a Page.
         * @summary Create Page
         * @param {PageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPagePagesPost(body: PageCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageRead> {
            const localVarFetchArgs = PageApiFetchParamCreator(configuration).createPagePagesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Page Language
         * @param {number} pageLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePageLanguagePageLanguagesPageLanguageIdDelete(pageLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = PageApiFetchParamCreator(configuration).deletePageLanguagePageLanguagesPageLanguageIdDelete(pageLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Page
         * @param {number} pageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePagePagesPageIdDelete(pageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = PageApiFetchParamCreator(configuration).deletePagePagesPageIdDelete(pageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Page Language
         * @param {number} pageLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPageLanguagePageLanguagesPageLanguageIdGet(pageLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageLanguageRead> {
            const localVarFetchArgs = PageApiFetchParamCreator(configuration).readPageLanguagePageLanguagesPageLanguageIdGet(pageLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all PageLanguage.
         * @summary Read Page Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPageLanguagesPageLanguagesGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PageLanguageRead>> {
            const localVarFetchArgs = PageApiFetchParamCreator(configuration).readPageLanguagesPageLanguagesGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Page
         * @param {number} pageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPagePagesPageIdGet(pageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageRead> {
            const localVarFetchArgs = PageApiFetchParamCreator(configuration).readPagePagesPageIdGet(pageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Page.
         * @summary Read Pages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPagesPagesGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PageRead>> {
            const localVarFetchArgs = PageApiFetchParamCreator(configuration).readPagesPagesGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Page Language
         * @param {PageLanguageUpdate} body 
         * @param {number} pageLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageLanguagePageLanguagesPageLanguageIdPatch(body: PageLanguageUpdate, pageLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageLanguageRead> {
            const localVarFetchArgs = PageApiFetchParamCreator(configuration).updatePageLanguagePageLanguagesPageLanguageIdPatch(body, pageLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Page
         * @param {PageUpdate} body 
         * @param {number} pageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePagePagesPageIdPatch(body: PageUpdate, pageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageRead> {
            const localVarFetchArgs = PageApiFetchParamCreator(configuration).updatePagePagesPageIdPatch(body, pageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PageApi - factory interface
 * @export
 */
export const PageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a PageLanguage.
         * @summary Create Page Language
         * @param {PageLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPageLanguagePageLanguagesPost(body: PageLanguageCreate, options?: any) {
            return PageApiFp(configuration).createPageLanguagePageLanguagesPost(body, options)(fetch, basePath);
        },
        /**
         * Create a Page.
         * @summary Create Page
         * @param {PageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPagePagesPost(body: PageCreate, options?: any) {
            return PageApiFp(configuration).createPagePagesPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Page Language
         * @param {number} pageLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePageLanguagePageLanguagesPageLanguageIdDelete(pageLanguageId: number, options?: any) {
            return PageApiFp(configuration).deletePageLanguagePageLanguagesPageLanguageIdDelete(pageLanguageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Page
         * @param {number} pageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePagePagesPageIdDelete(pageId: number, options?: any) {
            return PageApiFp(configuration).deletePagePagesPageIdDelete(pageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Page Language
         * @param {number} pageLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPageLanguagePageLanguagesPageLanguageIdGet(pageLanguageId: number, options?: any) {
            return PageApiFp(configuration).readPageLanguagePageLanguagesPageLanguageIdGet(pageLanguageId, options)(fetch, basePath);
        },
        /**
         * Get all PageLanguage.
         * @summary Read Page Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPageLanguagesPageLanguagesGet(q?: string, offset?: number, limit?: number, options?: any) {
            return PageApiFp(configuration).readPageLanguagesPageLanguagesGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Page
         * @param {number} pageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPagePagesPageIdGet(pageId: number, options?: any) {
            return PageApiFp(configuration).readPagePagesPageIdGet(pageId, options)(fetch, basePath);
        },
        /**
         * Get all Page.
         * @summary Read Pages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPagesPagesGet(q?: string, offset?: number, limit?: number, options?: any) {
            return PageApiFp(configuration).readPagesPagesGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Page Language
         * @param {PageLanguageUpdate} body 
         * @param {number} pageLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePageLanguagePageLanguagesPageLanguageIdPatch(body: PageLanguageUpdate, pageLanguageId: number, options?: any) {
            return PageApiFp(configuration).updatePageLanguagePageLanguagesPageLanguageIdPatch(body, pageLanguageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Page
         * @param {PageUpdate} body 
         * @param {number} pageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePagePagesPageIdPatch(body: PageUpdate, pageId: number, options?: any) {
            return PageApiFp(configuration).updatePagePagesPageIdPatch(body, pageId, options)(fetch, basePath);
        },
    };
};

/**
 * PageApi - object-oriented interface
 * @export
 * @class PageApi
 * @extends {BaseAPI}
 */
export class PageApi extends BaseAPI {
    /**
     * Create a PageLanguage.
     * @summary Create Page Language
     * @param {PageLanguageCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public createPageLanguagePageLanguagesPost(body: PageLanguageCreate, options?: any) {
        return PageApiFp(this.configuration).createPageLanguagePageLanguagesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a Page.
     * @summary Create Page
     * @param {PageCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public createPagePagesPost(body: PageCreate, options?: any) {
        return PageApiFp(this.configuration).createPagePagesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Page Language
     * @param {number} pageLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public deletePageLanguagePageLanguagesPageLanguageIdDelete(pageLanguageId: number, options?: any) {
        return PageApiFp(this.configuration).deletePageLanguagePageLanguagesPageLanguageIdDelete(pageLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Page
     * @param {number} pageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public deletePagePagesPageIdDelete(pageId: number, options?: any) {
        return PageApiFp(this.configuration).deletePagePagesPageIdDelete(pageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Page Language
     * @param {number} pageLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public readPageLanguagePageLanguagesPageLanguageIdGet(pageLanguageId: number, options?: any) {
        return PageApiFp(this.configuration).readPageLanguagePageLanguagesPageLanguageIdGet(pageLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all PageLanguage.
     * @summary Read Page Languages
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public readPageLanguagesPageLanguagesGet(q?: string, offset?: number, limit?: number, options?: any) {
        return PageApiFp(this.configuration).readPageLanguagesPageLanguagesGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Page
     * @param {number} pageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public readPagePagesPageIdGet(pageId: number, options?: any) {
        return PageApiFp(this.configuration).readPagePagesPageIdGet(pageId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all Page.
     * @summary Read Pages
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public readPagesPagesGet(q?: string, offset?: number, limit?: number, options?: any) {
        return PageApiFp(this.configuration).readPagesPagesGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Page Language
     * @param {PageLanguageUpdate} body 
     * @param {number} pageLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public updatePageLanguagePageLanguagesPageLanguageIdPatch(body: PageLanguageUpdate, pageLanguageId: number, options?: any) {
        return PageApiFp(this.configuration).updatePageLanguagePageLanguagesPageLanguageIdPatch(body, pageLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Page
     * @param {PageUpdate} body 
     * @param {number} pageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public updatePagePagesPageIdPatch(body: PageUpdate, pageId: number, options?: any) {
        return PageApiFp(this.configuration).updatePagePagesPageIdPatch(body, pageId, options)(this.fetch, this.basePath);
    }

}
/**
 * PostApi - fetch parameter creator
 * @export
 */
export const PostApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a PostLanguage.
         * @summary Create Post Language
         * @param {PostLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostLanguagePostLanguagesPost(body: PostLanguageCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPostLanguagePostLanguagesPost.');
            }
            const localVarPath = `/post_languages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostLanguageCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Post.
         * @summary Create Post
         * @param {PostCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostPostsPost(body: PostCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPostPostsPost.');
            }
            const localVarPath = `/posts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Post Language
         * @param {number} postLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostLanguagePostLanguagesPostLanguageIdDelete(postLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'postLanguageId' is not null or undefined
            if (postLanguageId === null || postLanguageId === undefined) {
                throw new RequiredError('postLanguageId','Required parameter postLanguageId was null or undefined when calling deletePostLanguagePostLanguagesPostLanguageIdDelete.');
            }
            const localVarPath = `/post_languages/{post_language_id}`
                .replace(`{${"post_language_id"}}`, encodeURIComponent(String(postLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Post
         * @param {number} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostPostsPostIdDelete(postId: number, options: any = {}): FetchArgs {
            // verify required parameter 'postId' is not null or undefined
            if (postId === null || postId === undefined) {
                throw new RequiredError('postId','Required parameter postId was null or undefined when calling deletePostPostsPostIdDelete.');
            }
            const localVarPath = `/posts/{post_id}`
                .replace(`{${"post_id"}}`, encodeURIComponent(String(postId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Post Language
         * @param {number} postLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPostLanguagePostLanguagesPostLanguageIdGet(postLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'postLanguageId' is not null or undefined
            if (postLanguageId === null || postLanguageId === undefined) {
                throw new RequiredError('postLanguageId','Required parameter postLanguageId was null or undefined when calling readPostLanguagePostLanguagesPostLanguageIdGet.');
            }
            const localVarPath = `/post_languages/{post_language_id}`
                .replace(`{${"post_language_id"}}`, encodeURIComponent(String(postLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all PostLanguage.
         * @summary Read Post Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPostLanguagesPostLanguagesGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/post_languages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Post
         * @param {number} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPostPostsPostIdGet(postId: number, options: any = {}): FetchArgs {
            // verify required parameter 'postId' is not null or undefined
            if (postId === null || postId === undefined) {
                throw new RequiredError('postId','Required parameter postId was null or undefined when calling readPostPostsPostIdGet.');
            }
            const localVarPath = `/posts/{post_id}`
                .replace(`{${"post_id"}}`, encodeURIComponent(String(postId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Post.
         * @summary Read Posts
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPostsPostsGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/posts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Post Language
         * @param {PostLanguageUpdate} body 
         * @param {number} postLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostLanguagePostLanguagesPostLanguageIdPatch(body: PostLanguageUpdate, postLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePostLanguagePostLanguagesPostLanguageIdPatch.');
            }
            // verify required parameter 'postLanguageId' is not null or undefined
            if (postLanguageId === null || postLanguageId === undefined) {
                throw new RequiredError('postLanguageId','Required parameter postLanguageId was null or undefined when calling updatePostLanguagePostLanguagesPostLanguageIdPatch.');
            }
            const localVarPath = `/post_languages/{post_language_id}`
                .replace(`{${"post_language_id"}}`, encodeURIComponent(String(postLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostLanguageUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Post
         * @param {PostUpdate} body 
         * @param {number} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostPostsPostIdPatch(body: PostUpdate, postId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePostPostsPostIdPatch.');
            }
            // verify required parameter 'postId' is not null or undefined
            if (postId === null || postId === undefined) {
                throw new RequiredError('postId','Required parameter postId was null or undefined when calling updatePostPostsPostIdPatch.');
            }
            const localVarPath = `/posts/{post_id}`
                .replace(`{${"post_id"}}`, encodeURIComponent(String(postId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostApi - functional programming interface
 * @export
 */
export const PostApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a PostLanguage.
         * @summary Create Post Language
         * @param {PostLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostLanguagePostLanguagesPost(body: PostLanguageCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostLanguageRead> {
            const localVarFetchArgs = PostApiFetchParamCreator(configuration).createPostLanguagePostLanguagesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a Post.
         * @summary Create Post
         * @param {PostCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostPostsPost(body: PostCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostRead> {
            const localVarFetchArgs = PostApiFetchParamCreator(configuration).createPostPostsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Post Language
         * @param {number} postLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostLanguagePostLanguagesPostLanguageIdDelete(postLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = PostApiFetchParamCreator(configuration).deletePostLanguagePostLanguagesPostLanguageIdDelete(postLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Post
         * @param {number} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostPostsPostIdDelete(postId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = PostApiFetchParamCreator(configuration).deletePostPostsPostIdDelete(postId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Post Language
         * @param {number} postLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPostLanguagePostLanguagesPostLanguageIdGet(postLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostLanguageRead> {
            const localVarFetchArgs = PostApiFetchParamCreator(configuration).readPostLanguagePostLanguagesPostLanguageIdGet(postLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all PostLanguage.
         * @summary Read Post Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPostLanguagesPostLanguagesGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PostLanguageRead>> {
            const localVarFetchArgs = PostApiFetchParamCreator(configuration).readPostLanguagesPostLanguagesGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Post
         * @param {number} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPostPostsPostIdGet(postId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostRead> {
            const localVarFetchArgs = PostApiFetchParamCreator(configuration).readPostPostsPostIdGet(postId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Post.
         * @summary Read Posts
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPostsPostsGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PostRead>> {
            const localVarFetchArgs = PostApiFetchParamCreator(configuration).readPostsPostsGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Post Language
         * @param {PostLanguageUpdate} body 
         * @param {number} postLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostLanguagePostLanguagesPostLanguageIdPatch(body: PostLanguageUpdate, postLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostLanguageRead> {
            const localVarFetchArgs = PostApiFetchParamCreator(configuration).updatePostLanguagePostLanguagesPostLanguageIdPatch(body, postLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Post
         * @param {PostUpdate} body 
         * @param {number} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostPostsPostIdPatch(body: PostUpdate, postId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostRead> {
            const localVarFetchArgs = PostApiFetchParamCreator(configuration).updatePostPostsPostIdPatch(body, postId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PostApi - factory interface
 * @export
 */
export const PostApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a PostLanguage.
         * @summary Create Post Language
         * @param {PostLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostLanguagePostLanguagesPost(body: PostLanguageCreate, options?: any) {
            return PostApiFp(configuration).createPostLanguagePostLanguagesPost(body, options)(fetch, basePath);
        },
        /**
         * Create a Post.
         * @summary Create Post
         * @param {PostCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPostPostsPost(body: PostCreate, options?: any) {
            return PostApiFp(configuration).createPostPostsPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Post Language
         * @param {number} postLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostLanguagePostLanguagesPostLanguageIdDelete(postLanguageId: number, options?: any) {
            return PostApiFp(configuration).deletePostLanguagePostLanguagesPostLanguageIdDelete(postLanguageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Post
         * @param {number} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePostPostsPostIdDelete(postId: number, options?: any) {
            return PostApiFp(configuration).deletePostPostsPostIdDelete(postId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Post Language
         * @param {number} postLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPostLanguagePostLanguagesPostLanguageIdGet(postLanguageId: number, options?: any) {
            return PostApiFp(configuration).readPostLanguagePostLanguagesPostLanguageIdGet(postLanguageId, options)(fetch, basePath);
        },
        /**
         * Get all PostLanguage.
         * @summary Read Post Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPostLanguagesPostLanguagesGet(q?: string, offset?: number, limit?: number, options?: any) {
            return PostApiFp(configuration).readPostLanguagesPostLanguagesGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Post
         * @param {number} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPostPostsPostIdGet(postId: number, options?: any) {
            return PostApiFp(configuration).readPostPostsPostIdGet(postId, options)(fetch, basePath);
        },
        /**
         * Get all Post.
         * @summary Read Posts
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPostsPostsGet(q?: string, offset?: number, limit?: number, options?: any) {
            return PostApiFp(configuration).readPostsPostsGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Post Language
         * @param {PostLanguageUpdate} body 
         * @param {number} postLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostLanguagePostLanguagesPostLanguageIdPatch(body: PostLanguageUpdate, postLanguageId: number, options?: any) {
            return PostApiFp(configuration).updatePostLanguagePostLanguagesPostLanguageIdPatch(body, postLanguageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Post
         * @param {PostUpdate} body 
         * @param {number} postId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostPostsPostIdPatch(body: PostUpdate, postId: number, options?: any) {
            return PostApiFp(configuration).updatePostPostsPostIdPatch(body, postId, options)(fetch, basePath);
        },
    };
};

/**
 * PostApi - object-oriented interface
 * @export
 * @class PostApi
 * @extends {BaseAPI}
 */
export class PostApi extends BaseAPI {
    /**
     * Create a PostLanguage.
     * @summary Create Post Language
     * @param {PostLanguageCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public createPostLanguagePostLanguagesPost(body: PostLanguageCreate, options?: any) {
        return PostApiFp(this.configuration).createPostLanguagePostLanguagesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a Post.
     * @summary Create Post
     * @param {PostCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public createPostPostsPost(body: PostCreate, options?: any) {
        return PostApiFp(this.configuration).createPostPostsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Post Language
     * @param {number} postLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public deletePostLanguagePostLanguagesPostLanguageIdDelete(postLanguageId: number, options?: any) {
        return PostApiFp(this.configuration).deletePostLanguagePostLanguagesPostLanguageIdDelete(postLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Post
     * @param {number} postId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public deletePostPostsPostIdDelete(postId: number, options?: any) {
        return PostApiFp(this.configuration).deletePostPostsPostIdDelete(postId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Post Language
     * @param {number} postLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public readPostLanguagePostLanguagesPostLanguageIdGet(postLanguageId: number, options?: any) {
        return PostApiFp(this.configuration).readPostLanguagePostLanguagesPostLanguageIdGet(postLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all PostLanguage.
     * @summary Read Post Languages
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public readPostLanguagesPostLanguagesGet(q?: string, offset?: number, limit?: number, options?: any) {
        return PostApiFp(this.configuration).readPostLanguagesPostLanguagesGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Post
     * @param {number} postId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public readPostPostsPostIdGet(postId: number, options?: any) {
        return PostApiFp(this.configuration).readPostPostsPostIdGet(postId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all Post.
     * @summary Read Posts
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public readPostsPostsGet(q?: string, offset?: number, limit?: number, options?: any) {
        return PostApiFp(this.configuration).readPostsPostsGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Post Language
     * @param {PostLanguageUpdate} body 
     * @param {number} postLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public updatePostLanguagePostLanguagesPostLanguageIdPatch(body: PostLanguageUpdate, postLanguageId: number, options?: any) {
        return PostApiFp(this.configuration).updatePostLanguagePostLanguagesPostLanguageIdPatch(body, postLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Post
     * @param {PostUpdate} body 
     * @param {number} postId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public updatePostPostsPostIdPatch(body: PostUpdate, postId: number, options?: any) {
        return PostApiFp(this.configuration).updatePostPostsPostIdPatch(body, postId, options)(this.fetch, this.basePath);
    }

}
/**
 * PublicationApi - fetch parameter creator
 * @export
 */
export const PublicationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a PublicationLanguage.
         * @summary Create Publication Language
         * @param {PublicationLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicationLanguagePublicationLanguagesPost(body: PublicationLanguageCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPublicationLanguagePublicationLanguagesPost.');
            }
            const localVarPath = `/publication_languages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublicationLanguageCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Publication.
         * @summary Create Publication
         * @param {PublicationCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicationPublicationsPost(body: PublicationCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPublicationPublicationsPost.');
            }
            const localVarPath = `/publications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublicationCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Publication Language
         * @param {number} publicationLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicationLanguagePublicationLanguagesPublicationLanguageIdDelete(publicationLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'publicationLanguageId' is not null or undefined
            if (publicationLanguageId === null || publicationLanguageId === undefined) {
                throw new RequiredError('publicationLanguageId','Required parameter publicationLanguageId was null or undefined when calling deletePublicationLanguagePublicationLanguagesPublicationLanguageIdDelete.');
            }
            const localVarPath = `/publication_languages/{publication_language_id}`
                .replace(`{${"publication_language_id"}}`, encodeURIComponent(String(publicationLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Publication
         * @param {number} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicationPublicationsPublicationIdDelete(publicationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'publicationId' is not null or undefined
            if (publicationId === null || publicationId === undefined) {
                throw new RequiredError('publicationId','Required parameter publicationId was null or undefined when calling deletePublicationPublicationsPublicationIdDelete.');
            }
            const localVarPath = `/publications/{publication_id}`
                .replace(`{${"publication_id"}}`, encodeURIComponent(String(publicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Publication Language
         * @param {number} publicationLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPublicationLanguagePublicationLanguagesPublicationLanguageIdGet(publicationLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'publicationLanguageId' is not null or undefined
            if (publicationLanguageId === null || publicationLanguageId === undefined) {
                throw new RequiredError('publicationLanguageId','Required parameter publicationLanguageId was null or undefined when calling readPublicationLanguagePublicationLanguagesPublicationLanguageIdGet.');
            }
            const localVarPath = `/publication_languages/{publication_language_id}`
                .replace(`{${"publication_language_id"}}`, encodeURIComponent(String(publicationLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all PublicationLanguage.
         * @summary Read Publication Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPublicationLanguagesPublicationLanguagesGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/publication_languages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Publication
         * @param {number} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPublicationPublicationsPublicationIdGet(publicationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'publicationId' is not null or undefined
            if (publicationId === null || publicationId === undefined) {
                throw new RequiredError('publicationId','Required parameter publicationId was null or undefined when calling readPublicationPublicationsPublicationIdGet.');
            }
            const localVarPath = `/publications/{publication_id}`
                .replace(`{${"publication_id"}}`, encodeURIComponent(String(publicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Publication.
         * @summary Read Publications
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPublicationsPublicationsGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/publications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Publication Language
         * @param {PublicationLanguageUpdate} body 
         * @param {number} publicationLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicationLanguagePublicationLanguagesPublicationLanguageIdPatch(body: PublicationLanguageUpdate, publicationLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePublicationLanguagePublicationLanguagesPublicationLanguageIdPatch.');
            }
            // verify required parameter 'publicationLanguageId' is not null or undefined
            if (publicationLanguageId === null || publicationLanguageId === undefined) {
                throw new RequiredError('publicationLanguageId','Required parameter publicationLanguageId was null or undefined when calling updatePublicationLanguagePublicationLanguagesPublicationLanguageIdPatch.');
            }
            const localVarPath = `/publication_languages/{publication_language_id}`
                .replace(`{${"publication_language_id"}}`, encodeURIComponent(String(publicationLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublicationLanguageUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Publication
         * @param {PublicationUpdate} body 
         * @param {number} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicationPublicationsPublicationIdPatch(body: PublicationUpdate, publicationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePublicationPublicationsPublicationIdPatch.');
            }
            // verify required parameter 'publicationId' is not null or undefined
            if (publicationId === null || publicationId === undefined) {
                throw new RequiredError('publicationId','Required parameter publicationId was null or undefined when calling updatePublicationPublicationsPublicationIdPatch.');
            }
            const localVarPath = `/publications/{publication_id}`
                .replace(`{${"publication_id"}}`, encodeURIComponent(String(publicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublicationUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicationApi - functional programming interface
 * @export
 */
export const PublicationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a PublicationLanguage.
         * @summary Create Publication Language
         * @param {PublicationLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicationLanguagePublicationLanguagesPost(body: PublicationLanguageCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicationLanguageRead> {
            const localVarFetchArgs = PublicationApiFetchParamCreator(configuration).createPublicationLanguagePublicationLanguagesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a Publication.
         * @summary Create Publication
         * @param {PublicationCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicationPublicationsPost(body: PublicationCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicationRead> {
            const localVarFetchArgs = PublicationApiFetchParamCreator(configuration).createPublicationPublicationsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Publication Language
         * @param {number} publicationLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicationLanguagePublicationLanguagesPublicationLanguageIdDelete(publicationLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = PublicationApiFetchParamCreator(configuration).deletePublicationLanguagePublicationLanguagesPublicationLanguageIdDelete(publicationLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Publication
         * @param {number} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicationPublicationsPublicationIdDelete(publicationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = PublicationApiFetchParamCreator(configuration).deletePublicationPublicationsPublicationIdDelete(publicationId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Publication Language
         * @param {number} publicationLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPublicationLanguagePublicationLanguagesPublicationLanguageIdGet(publicationLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicationLanguageRead> {
            const localVarFetchArgs = PublicationApiFetchParamCreator(configuration).readPublicationLanguagePublicationLanguagesPublicationLanguageIdGet(publicationLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all PublicationLanguage.
         * @summary Read Publication Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPublicationLanguagesPublicationLanguagesGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PublicationLanguageRead>> {
            const localVarFetchArgs = PublicationApiFetchParamCreator(configuration).readPublicationLanguagesPublicationLanguagesGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Publication
         * @param {number} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPublicationPublicationsPublicationIdGet(publicationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicationRead> {
            const localVarFetchArgs = PublicationApiFetchParamCreator(configuration).readPublicationPublicationsPublicationIdGet(publicationId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Publication.
         * @summary Read Publications
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPublicationsPublicationsGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PublicationRead>> {
            const localVarFetchArgs = PublicationApiFetchParamCreator(configuration).readPublicationsPublicationsGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Publication Language
         * @param {PublicationLanguageUpdate} body 
         * @param {number} publicationLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicationLanguagePublicationLanguagesPublicationLanguageIdPatch(body: PublicationLanguageUpdate, publicationLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicationLanguageRead> {
            const localVarFetchArgs = PublicationApiFetchParamCreator(configuration).updatePublicationLanguagePublicationLanguagesPublicationLanguageIdPatch(body, publicationLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Publication
         * @param {PublicationUpdate} body 
         * @param {number} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicationPublicationsPublicationIdPatch(body: PublicationUpdate, publicationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PublicationRead> {
            const localVarFetchArgs = PublicationApiFetchParamCreator(configuration).updatePublicationPublicationsPublicationIdPatch(body, publicationId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PublicationApi - factory interface
 * @export
 */
export const PublicationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a PublicationLanguage.
         * @summary Create Publication Language
         * @param {PublicationLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicationLanguagePublicationLanguagesPost(body: PublicationLanguageCreate, options?: any) {
            return PublicationApiFp(configuration).createPublicationLanguagePublicationLanguagesPost(body, options)(fetch, basePath);
        },
        /**
         * Create a Publication.
         * @summary Create Publication
         * @param {PublicationCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicationPublicationsPost(body: PublicationCreate, options?: any) {
            return PublicationApiFp(configuration).createPublicationPublicationsPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Publication Language
         * @param {number} publicationLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicationLanguagePublicationLanguagesPublicationLanguageIdDelete(publicationLanguageId: number, options?: any) {
            return PublicationApiFp(configuration).deletePublicationLanguagePublicationLanguagesPublicationLanguageIdDelete(publicationLanguageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Publication
         * @param {number} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicationPublicationsPublicationIdDelete(publicationId: number, options?: any) {
            return PublicationApiFp(configuration).deletePublicationPublicationsPublicationIdDelete(publicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Publication Language
         * @param {number} publicationLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPublicationLanguagePublicationLanguagesPublicationLanguageIdGet(publicationLanguageId: number, options?: any) {
            return PublicationApiFp(configuration).readPublicationLanguagePublicationLanguagesPublicationLanguageIdGet(publicationLanguageId, options)(fetch, basePath);
        },
        /**
         * Get all PublicationLanguage.
         * @summary Read Publication Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPublicationLanguagesPublicationLanguagesGet(q?: string, offset?: number, limit?: number, options?: any) {
            return PublicationApiFp(configuration).readPublicationLanguagesPublicationLanguagesGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Publication
         * @param {number} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPublicationPublicationsPublicationIdGet(publicationId: number, options?: any) {
            return PublicationApiFp(configuration).readPublicationPublicationsPublicationIdGet(publicationId, options)(fetch, basePath);
        },
        /**
         * Get all Publication.
         * @summary Read Publications
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPublicationsPublicationsGet(q?: string, offset?: number, limit?: number, options?: any) {
            return PublicationApiFp(configuration).readPublicationsPublicationsGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Publication Language
         * @param {PublicationLanguageUpdate} body 
         * @param {number} publicationLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicationLanguagePublicationLanguagesPublicationLanguageIdPatch(body: PublicationLanguageUpdate, publicationLanguageId: number, options?: any) {
            return PublicationApiFp(configuration).updatePublicationLanguagePublicationLanguagesPublicationLanguageIdPatch(body, publicationLanguageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Publication
         * @param {PublicationUpdate} body 
         * @param {number} publicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicationPublicationsPublicationIdPatch(body: PublicationUpdate, publicationId: number, options?: any) {
            return PublicationApiFp(configuration).updatePublicationPublicationsPublicationIdPatch(body, publicationId, options)(fetch, basePath);
        },
    };
};

/**
 * PublicationApi - object-oriented interface
 * @export
 * @class PublicationApi
 * @extends {BaseAPI}
 */
export class PublicationApi extends BaseAPI {
    /**
     * Create a PublicationLanguage.
     * @summary Create Publication Language
     * @param {PublicationLanguageCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public createPublicationLanguagePublicationLanguagesPost(body: PublicationLanguageCreate, options?: any) {
        return PublicationApiFp(this.configuration).createPublicationLanguagePublicationLanguagesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a Publication.
     * @summary Create Publication
     * @param {PublicationCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public createPublicationPublicationsPost(body: PublicationCreate, options?: any) {
        return PublicationApiFp(this.configuration).createPublicationPublicationsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Publication Language
     * @param {number} publicationLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public deletePublicationLanguagePublicationLanguagesPublicationLanguageIdDelete(publicationLanguageId: number, options?: any) {
        return PublicationApiFp(this.configuration).deletePublicationLanguagePublicationLanguagesPublicationLanguageIdDelete(publicationLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Publication
     * @param {number} publicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public deletePublicationPublicationsPublicationIdDelete(publicationId: number, options?: any) {
        return PublicationApiFp(this.configuration).deletePublicationPublicationsPublicationIdDelete(publicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Publication Language
     * @param {number} publicationLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public readPublicationLanguagePublicationLanguagesPublicationLanguageIdGet(publicationLanguageId: number, options?: any) {
        return PublicationApiFp(this.configuration).readPublicationLanguagePublicationLanguagesPublicationLanguageIdGet(publicationLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all PublicationLanguage.
     * @summary Read Publication Languages
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public readPublicationLanguagesPublicationLanguagesGet(q?: string, offset?: number, limit?: number, options?: any) {
        return PublicationApiFp(this.configuration).readPublicationLanguagesPublicationLanguagesGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Publication
     * @param {number} publicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public readPublicationPublicationsPublicationIdGet(publicationId: number, options?: any) {
        return PublicationApiFp(this.configuration).readPublicationPublicationsPublicationIdGet(publicationId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all Publication.
     * @summary Read Publications
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public readPublicationsPublicationsGet(q?: string, offset?: number, limit?: number, options?: any) {
        return PublicationApiFp(this.configuration).readPublicationsPublicationsGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Publication Language
     * @param {PublicationLanguageUpdate} body 
     * @param {number} publicationLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public updatePublicationLanguagePublicationLanguagesPublicationLanguageIdPatch(body: PublicationLanguageUpdate, publicationLanguageId: number, options?: any) {
        return PublicationApiFp(this.configuration).updatePublicationLanguagePublicationLanguagesPublicationLanguageIdPatch(body, publicationLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Publication
     * @param {PublicationUpdate} body 
     * @param {number} publicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicationApi
     */
    public updatePublicationPublicationsPublicationIdPatch(body: PublicationUpdate, publicationId: number, options?: any) {
        return PublicationApiFp(this.configuration).updatePublicationPublicationsPublicationIdPatch(body, publicationId, options)(this.fetch, this.basePath);
    }

}
/**
 * SiteApi - fetch parameter creator
 * @export
 */
export const SiteApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a SiteLanguage.
         * @summary Create Site Language
         * @param {SiteLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteLanguageSiteLanguagesPost(body: SiteLanguageCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSiteLanguageSiteLanguagesPost.');
            }
            const localVarPath = `/site_languages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SiteLanguageCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Site.
         * @summary Create Site
         * @param {SiteCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteSitesPost(body: SiteCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSiteSitesPost.');
            }
            const localVarPath = `/sites`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SiteCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Site Language
         * @param {number} siteLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteLanguageSiteLanguagesSiteLanguageIdDelete(siteLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'siteLanguageId' is not null or undefined
            if (siteLanguageId === null || siteLanguageId === undefined) {
                throw new RequiredError('siteLanguageId','Required parameter siteLanguageId was null or undefined when calling deleteSiteLanguageSiteLanguagesSiteLanguageIdDelete.');
            }
            const localVarPath = `/site_languages/{site_language_id}`
                .replace(`{${"site_language_id"}}`, encodeURIComponent(String(siteLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Site
         * @param {number} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteSitesSiteIdDelete(siteId: number, options: any = {}): FetchArgs {
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling deleteSiteSitesSiteIdDelete.');
            }
            const localVarPath = `/sites/{site_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Site Language
         * @param {number} siteLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSiteLanguageSiteLanguagesSiteLanguageIdGet(siteLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'siteLanguageId' is not null or undefined
            if (siteLanguageId === null || siteLanguageId === undefined) {
                throw new RequiredError('siteLanguageId','Required parameter siteLanguageId was null or undefined when calling readSiteLanguageSiteLanguagesSiteLanguageIdGet.');
            }
            const localVarPath = `/site_languages/{site_language_id}`
                .replace(`{${"site_language_id"}}`, encodeURIComponent(String(siteLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all SiteLanguage.
         * @summary Read Site Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSiteLanguagesSiteLanguagesGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/site_languages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Site
         * @param {number} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSiteSitesSiteIdGet(siteId: number, options: any = {}): FetchArgs {
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling readSiteSitesSiteIdGet.');
            }
            const localVarPath = `/sites/{site_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Site.
         * @summary Read Sites
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSitesSitesGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/sites`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Site Language
         * @param {SiteLanguageUpdate} body 
         * @param {number} siteLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteLanguageSiteLanguagesSiteLanguageIdPatch(body: SiteLanguageUpdate, siteLanguageId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSiteLanguageSiteLanguagesSiteLanguageIdPatch.');
            }
            // verify required parameter 'siteLanguageId' is not null or undefined
            if (siteLanguageId === null || siteLanguageId === undefined) {
                throw new RequiredError('siteLanguageId','Required parameter siteLanguageId was null or undefined when calling updateSiteLanguageSiteLanguagesSiteLanguageIdPatch.');
            }
            const localVarPath = `/site_languages/{site_language_id}`
                .replace(`{${"site_language_id"}}`, encodeURIComponent(String(siteLanguageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SiteLanguageUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Site
         * @param {SiteUpdate} body 
         * @param {number} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteSitesSiteIdPatch(body: SiteUpdate, siteId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSiteSitesSiteIdPatch.');
            }
            // verify required parameter 'siteId' is not null or undefined
            if (siteId === null || siteId === undefined) {
                throw new RequiredError('siteId','Required parameter siteId was null or undefined when calling updateSiteSitesSiteIdPatch.');
            }
            const localVarPath = `/sites/{site_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SiteUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SiteApi - functional programming interface
 * @export
 */
export const SiteApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a SiteLanguage.
         * @summary Create Site Language
         * @param {SiteLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteLanguageSiteLanguagesPost(body: SiteLanguageCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SiteLanguageRead> {
            const localVarFetchArgs = SiteApiFetchParamCreator(configuration).createSiteLanguageSiteLanguagesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a Site.
         * @summary Create Site
         * @param {SiteCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteSitesPost(body: SiteCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SiteRead> {
            const localVarFetchArgs = SiteApiFetchParamCreator(configuration).createSiteSitesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Site Language
         * @param {number} siteLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteLanguageSiteLanguagesSiteLanguageIdDelete(siteLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = SiteApiFetchParamCreator(configuration).deleteSiteLanguageSiteLanguagesSiteLanguageIdDelete(siteLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Site
         * @param {number} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteSitesSiteIdDelete(siteId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = SiteApiFetchParamCreator(configuration).deleteSiteSitesSiteIdDelete(siteId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Site Language
         * @param {number} siteLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSiteLanguageSiteLanguagesSiteLanguageIdGet(siteLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SiteLanguageRead> {
            const localVarFetchArgs = SiteApiFetchParamCreator(configuration).readSiteLanguageSiteLanguagesSiteLanguageIdGet(siteLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all SiteLanguage.
         * @summary Read Site Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSiteLanguagesSiteLanguagesGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SiteLanguageRead>> {
            const localVarFetchArgs = SiteApiFetchParamCreator(configuration).readSiteLanguagesSiteLanguagesGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Read Site
         * @param {number} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSiteSitesSiteIdGet(siteId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SiteRead> {
            const localVarFetchArgs = SiteApiFetchParamCreator(configuration).readSiteSitesSiteIdGet(siteId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Site.
         * @summary Read Sites
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSitesSitesGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SiteRead>> {
            const localVarFetchArgs = SiteApiFetchParamCreator(configuration).readSitesSitesGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Site Language
         * @param {SiteLanguageUpdate} body 
         * @param {number} siteLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteLanguageSiteLanguagesSiteLanguageIdPatch(body: SiteLanguageUpdate, siteLanguageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SiteLanguageRead> {
            const localVarFetchArgs = SiteApiFetchParamCreator(configuration).updateSiteLanguageSiteLanguagesSiteLanguageIdPatch(body, siteLanguageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Site
         * @param {SiteUpdate} body 
         * @param {number} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteSitesSiteIdPatch(body: SiteUpdate, siteId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SiteRead> {
            const localVarFetchArgs = SiteApiFetchParamCreator(configuration).updateSiteSitesSiteIdPatch(body, siteId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SiteApi - factory interface
 * @export
 */
export const SiteApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a SiteLanguage.
         * @summary Create Site Language
         * @param {SiteLanguageCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteLanguageSiteLanguagesPost(body: SiteLanguageCreate, options?: any) {
            return SiteApiFp(configuration).createSiteLanguageSiteLanguagesPost(body, options)(fetch, basePath);
        },
        /**
         * Create a Site.
         * @summary Create Site
         * @param {SiteCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSiteSitesPost(body: SiteCreate, options?: any) {
            return SiteApiFp(configuration).createSiteSitesPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Site Language
         * @param {number} siteLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteLanguageSiteLanguagesSiteLanguageIdDelete(siteLanguageId: number, options?: any) {
            return SiteApiFp(configuration).deleteSiteLanguageSiteLanguagesSiteLanguageIdDelete(siteLanguageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Site
         * @param {number} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSiteSitesSiteIdDelete(siteId: number, options?: any) {
            return SiteApiFp(configuration).deleteSiteSitesSiteIdDelete(siteId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Site Language
         * @param {number} siteLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSiteLanguageSiteLanguagesSiteLanguageIdGet(siteLanguageId: number, options?: any) {
            return SiteApiFp(configuration).readSiteLanguageSiteLanguagesSiteLanguageIdGet(siteLanguageId, options)(fetch, basePath);
        },
        /**
         * Get all SiteLanguage.
         * @summary Read Site Languages
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSiteLanguagesSiteLanguagesGet(q?: string, offset?: number, limit?: number, options?: any) {
            return SiteApiFp(configuration).readSiteLanguagesSiteLanguagesGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Read Site
         * @param {number} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSiteSitesSiteIdGet(siteId: number, options?: any) {
            return SiteApiFp(configuration).readSiteSitesSiteIdGet(siteId, options)(fetch, basePath);
        },
        /**
         * Get all Site.
         * @summary Read Sites
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSitesSitesGet(q?: string, offset?: number, limit?: number, options?: any) {
            return SiteApiFp(configuration).readSitesSitesGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Site Language
         * @param {SiteLanguageUpdate} body 
         * @param {number} siteLanguageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteLanguageSiteLanguagesSiteLanguageIdPatch(body: SiteLanguageUpdate, siteLanguageId: number, options?: any) {
            return SiteApiFp(configuration).updateSiteLanguageSiteLanguagesSiteLanguageIdPatch(body, siteLanguageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Site
         * @param {SiteUpdate} body 
         * @param {number} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSiteSitesSiteIdPatch(body: SiteUpdate, siteId: number, options?: any) {
            return SiteApiFp(configuration).updateSiteSitesSiteIdPatch(body, siteId, options)(fetch, basePath);
        },
    };
};

/**
 * SiteApi - object-oriented interface
 * @export
 * @class SiteApi
 * @extends {BaseAPI}
 */
export class SiteApi extends BaseAPI {
    /**
     * Create a SiteLanguage.
     * @summary Create Site Language
     * @param {SiteLanguageCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public createSiteLanguageSiteLanguagesPost(body: SiteLanguageCreate, options?: any) {
        return SiteApiFp(this.configuration).createSiteLanguageSiteLanguagesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a Site.
     * @summary Create Site
     * @param {SiteCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public createSiteSitesPost(body: SiteCreate, options?: any) {
        return SiteApiFp(this.configuration).createSiteSitesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Site Language
     * @param {number} siteLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public deleteSiteLanguageSiteLanguagesSiteLanguageIdDelete(siteLanguageId: number, options?: any) {
        return SiteApiFp(this.configuration).deleteSiteLanguageSiteLanguagesSiteLanguageIdDelete(siteLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Site
     * @param {number} siteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public deleteSiteSitesSiteIdDelete(siteId: number, options?: any) {
        return SiteApiFp(this.configuration).deleteSiteSitesSiteIdDelete(siteId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Site Language
     * @param {number} siteLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public readSiteLanguageSiteLanguagesSiteLanguageIdGet(siteLanguageId: number, options?: any) {
        return SiteApiFp(this.configuration).readSiteLanguageSiteLanguagesSiteLanguageIdGet(siteLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all SiteLanguage.
     * @summary Read Site Languages
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public readSiteLanguagesSiteLanguagesGet(q?: string, offset?: number, limit?: number, options?: any) {
        return SiteApiFp(this.configuration).readSiteLanguagesSiteLanguagesGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Read Site
     * @param {number} siteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public readSiteSitesSiteIdGet(siteId: number, options?: any) {
        return SiteApiFp(this.configuration).readSiteSitesSiteIdGet(siteId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all Site.
     * @summary Read Sites
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public readSitesSitesGet(q?: string, offset?: number, limit?: number, options?: any) {
        return SiteApiFp(this.configuration).readSitesSitesGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Site Language
     * @param {SiteLanguageUpdate} body 
     * @param {number} siteLanguageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public updateSiteLanguageSiteLanguagesSiteLanguageIdPatch(body: SiteLanguageUpdate, siteLanguageId: number, options?: any) {
        return SiteApiFp(this.configuration).updateSiteLanguageSiteLanguagesSiteLanguageIdPatch(body, siteLanguageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Site
     * @param {SiteUpdate} body 
     * @param {number} siteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public updateSiteSitesSiteIdPatch(body: SiteUpdate, siteId: number, options?: any) {
        return SiteApiFp(this.configuration).updateSiteSitesSiteIdPatch(body, siteId, options)(this.fetch, this.basePath);
    }

}
/**
 * TokenApi - fetch parameter creator
 * @export
 */
export const TokenApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Token
         * @param {string} grantType 
         * @param {string} username 
         * @param {string} password 
         * @param {string} scope 
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTokenTokenPost(grantType: string, username: string, password: string, scope: string, clientId: string, clientSecret: string, options: any = {}): FetchArgs {
            // verify required parameter 'grantType' is not null or undefined
            if (grantType === null || grantType === undefined) {
                throw new RequiredError('grantType','Required parameter grantType was null or undefined when calling createTokenTokenPost.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling createTokenTokenPost.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling createTokenTokenPost.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling createTokenTokenPost.');
            }
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling createTokenTokenPost.');
            }
            // verify required parameter 'clientSecret' is not null or undefined
            if (clientSecret === null || clientSecret === undefined) {
                throw new RequiredError('clientSecret','Required parameter clientSecret was null or undefined when calling createTokenTokenPost.');
            }
            const localVarPath = `/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (grantType !== undefined) {
                localVarFormParams.set('grant_type', grantType as any);
            }

            if (username !== undefined) {
                localVarFormParams.set('username', username as any);
            }

            if (password !== undefined) {
                localVarFormParams.set('password', password as any);
            }

            if (scope !== undefined) {
                localVarFormParams.set('scope', scope as any);
            }

            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId as any);
            }

            if (clientSecret !== undefined) {
                localVarFormParams.set('client_secret', clientSecret as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Token
         * @param {string} grantType 
         * @param {string} username 
         * @param {string} password 
         * @param {string} scope 
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTokenTokenPost(grantType: string, username: string, password: string, scope: string, clientId: string, clientSecret: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Token> {
            const localVarFetchArgs = TokenApiFetchParamCreator(configuration).createTokenTokenPost(grantType, username, password, scope, clientId, clientSecret, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create Token
         * @param {string} grantType 
         * @param {string} username 
         * @param {string} password 
         * @param {string} scope 
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTokenTokenPost(grantType: string, username: string, password: string, scope: string, clientId: string, clientSecret: string, options?: any) {
            return TokenApiFp(configuration).createTokenTokenPost(grantType, username, password, scope, clientId, clientSecret, options)(fetch, basePath);
        },
    };
};

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
    /**
     * 
     * @summary Create Token
     * @param {string} grantType 
     * @param {string} username 
     * @param {string} password 
     * @param {string} scope 
     * @param {string} clientId 
     * @param {string} clientSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public createTokenTokenPost(grantType: string, username: string, password: string, scope: string, clientId: string, clientSecret: string, options?: any) {
        return TokenApiFp(this.configuration).createTokenTokenPost(grantType, username, password, scope, clientId, clientSecret, options)(this.fetch, this.basePath);
    }

}
/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new User
         * @summary Create User
         * @param {UserCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsersPost(body: UserCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUserUsersPost.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a User
         * @summary Delete User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsersUserIdDelete(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserUsersUserIdDelete.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Users
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUsersMeGet(options: any = {}): FetchArgs {
            const localVarPath = `/users/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a User by ID
         * @summary Get User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsersUserIdGet(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserUsersUserIdGet.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Users. staff [ok] admin [ok]
         * @summary Get Users
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsersGet(q?: string, offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a User
         * @summary Update User
         * @param {UserUpdate} body 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUsersUserIdPatch(body: UserUpdate, userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUserUsersUserIdPatch.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserUsersUserIdPatch.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("OAuth2PasswordBearer", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new User
         * @summary Create User
         * @param {UserCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsersPost(body: UserCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserRead> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).createUserUsersPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a User
         * @summary Delete User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsersUserIdDelete(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuccessResponseModel> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteUserUsersUserIdDelete(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Users
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUsersMeGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserRead> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getCurrentUserUsersMeGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a User by ID
         * @summary Get User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsersUserIdGet(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserRead> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserUsersUserIdGet(userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Users. staff [ok] admin [ok]
         * @summary Get Users
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsersGet(q?: string, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserRead>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUsersUsersGet(q, offset, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a User
         * @summary Update User
         * @param {UserUpdate} body 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUsersUserIdPatch(body: UserUpdate, userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserRead> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateUserUsersUserIdPatch(body, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new User
         * @summary Create User
         * @param {UserCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsersPost(body: UserCreate, options?: any) {
            return UserApiFp(configuration).createUserUsersPost(body, options)(fetch, basePath);
        },
        /**
         * Delete a User
         * @summary Delete User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsersUserIdDelete(userId: number, options?: any) {
            return UserApiFp(configuration).deleteUserUsersUserIdDelete(userId, options)(fetch, basePath);
        },
        /**
         * Get all Users
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUsersMeGet(options?: any) {
            return UserApiFp(configuration).getCurrentUserUsersMeGet(options)(fetch, basePath);
        },
        /**
         * Get a User by ID
         * @summary Get User
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsersUserIdGet(userId: number, options?: any) {
            return UserApiFp(configuration).getUserUsersUserIdGet(userId, options)(fetch, basePath);
        },
        /**
         * Get all Users. staff [ok] admin [ok]
         * @summary Get Users
         * @param {string} [q] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsersGet(q?: string, offset?: number, limit?: number, options?: any) {
            return UserApiFp(configuration).getUsersUsersGet(q, offset, limit, options)(fetch, basePath);
        },
        /**
         * Update a User
         * @summary Update User
         * @param {UserUpdate} body 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserUsersUserIdPatch(body: UserUpdate, userId: number, options?: any) {
            return UserApiFp(configuration).updateUserUsersUserIdPatch(body, userId, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Create a new User
     * @summary Create User
     * @param {UserCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUserUsersPost(body: UserCreate, options?: any) {
        return UserApiFp(this.configuration).createUserUsersPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a User
     * @summary Delete User
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUserUsersUserIdDelete(userId: number, options?: any) {
        return UserApiFp(this.configuration).deleteUserUsersUserIdDelete(userId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all Users
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrentUserUsersMeGet(options?: any) {
        return UserApiFp(this.configuration).getCurrentUserUsersMeGet(options)(this.fetch, this.basePath);
    }

    /**
     * Get a User by ID
     * @summary Get User
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserUsersUserIdGet(userId: number, options?: any) {
        return UserApiFp(this.configuration).getUserUsersUserIdGet(userId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all Users. staff [ok] admin [ok]
     * @summary Get Users
     * @param {string} [q] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsersUsersGet(q?: string, offset?: number, limit?: number, options?: any) {
        return UserApiFp(this.configuration).getUsersUsersGet(q, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Update a User
     * @summary Update User
     * @param {UserUpdate} body 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserUsersUserIdPatch(body: UserUpdate, userId: number, options?: any) {
        return UserApiFp(this.configuration).updateUserUsersUserIdPatch(body, userId, options)(this.fetch, this.basePath);
    }

}
